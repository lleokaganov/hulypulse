// hget hset TODO
// статистику TODO

// -------------------------------

use crate::config::{CONFIG, RedisMode};

use std::time::{SystemTime, UNIX_EPOCH};

pub enum Ttl {
    Sec(usize), // EX
    At(u64),   // EXAT (timestamp in seconds)
}

pub enum SaveMode {
    Upsert, // default: set or overwrite
    Insert, // only if not exists (NX)
    Update, // only if exists (XX)
}

use redis::{
    AsyncCommands, RedisResult,
    ToRedisArgs,
    Client, ConnectionInfo, ProtocolVersion, RedisConnectionInfo, aio::MultiplexedConnection };
use url::Url;

use serde::{Deserialize, Serialize};

#[derive(Debug, Serialize)]
pub struct RedisArray {
    pub workspace: String,
    pub key: String,
    pub data: String,
    pub expires_at: Option<u64>, // секунды до истечения TTL
}

fn error(msg: &'static str) -> redis::RedisResult<()> {
    Err(redis::RedisError::from(( redis::ErrorKind::ExtensionError, msg )))
}

/// redis_read(&connection,key)

#[allow(dead_code)]
pub async fn redis_read(
    conn: &mut MultiplexedConnection,
    workspace: &str,
    key: &str,
) -> redis::RedisResult<Option<RedisArray>> {

    let data: Option<String> = redis::cmd("HGET").arg(workspace).arg(key).query_async(conn).await?;
    let Some(data) = data else { return Ok(None); };

    // let ttl: i64 = redis::cmd("TTL").arg(redis_key).query_async(conn).await?;
    let ttl: i64 = redis::cmd("TTL").arg(workspace).arg(key).query_async(conn).await?;
    let expires_at = if ttl >= 0 { Some(ttl as u64) } else { None }; // -1 (нет TTL), -2 (нет ключа)

    Ok(Some(RedisArray {
        workspace: workspace.to_string(),
        key: key.to_string(),
        data,
        expires_at,
    }))
}


/*
EX — срок жизни в секундах (e.g. EX 60 = 1 минута).
EXAT — дата истечения в секундах с эпохи Unix.
KEEPTTL — сохраняет текущий TTL ключа при перезаписи.

Нет, несложно — Redis уже поддерживает это с помощью флагов NX и XX:
    NX — записать только если ключ не существует
    XX — перезаписать только если ключ уже существует

Ты просто добавляешь .arg("NX") или .arg("XX") в команду SET.
Варианты:
    SET key val EX 60 NX — с TTL, только если не существует
    SET key val XX — только если уже существует, без TTL
    SET key val — просто перезаписать, без TTL

*/

/// TTL sec
/// redis_save(&mut conn, "key", "val", Some(Ttl::Sec(300)), Some(SaveMode::Insert)).await?;
///
/// TTL at
/// let at_unixtime: u64 = SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs() + 600;
/// redis_save(&mut conn, "key", "val", Some(Ttl::At(at_unixtime)), Some(SaveMode::Update)).await?;
///
/// w/o TTL (CONFIG.max_ttl)
/// redis_save(&mut conn, "key", "val", None, None).await?;

#[allow(dead_code)]
pub async fn redis_save<T: ToRedisArgs>(
    conn: &mut MultiplexedConnection,
    workspace: &str,
    key: &str,
    value: T,
    ttl: Option<Ttl>,
    mode: Option<SaveMode>,
) -> RedisResult<()> {

    // TTL variants
    match ttl {
        Some(Ttl::Sec(secs)) => {
	    if secs == 0 {
		return error("TTL must be > 0");
	    }
	    if secs > CONFIG.max_ttl {
		return error("TTL exceeds MAX_TTL");
	    }
	    cmd.arg("EX").arg(secs);
	}
        Some(Ttl::At(timestamp)) => {
	    let now = SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs();
    	    if timestamp <= now {
		return error("TTL timestamp is in the past");
	    }
    	    if timestamp - now > CONFIG.max_ttl as u64 {
		return error("TTL timestamp exceeds MAX_TTL limit");
	    }
	    cmd.arg("EXAT").arg(timestamp);
	}
        None => { cmd.arg("EX").arg(CONFIG.max_ttl); }
    }


    let mut cmd = redis::cmd("HSET");
    cmd.arg(workspace).arg(key).arg(value).query_async(conn).await?;

redis::cmd("HEXPIRE")
    .arg(workspace)
    .arg(ttl_seconds)
    .arg("FIELDS")
    .arg(1).arg(key)
    .query_async(conn).await?;



    // Mode variants
    match mode.unwrap_or(SaveMode::Upsert) {
        SaveMode::Upsert => { } // nothing
        SaveMode::Insert => { cmd.arg("NX"); }
        SaveMode::Update => { cmd.arg("XX"); }
    }

    let res: Option<String> = cmd.query_async(&mut *conn).await?;

    if res.is_none() { // nil - if NX/XX error
	return error("SET failed: NX/XX condition not met");
    } else {
        Ok(())
    }
}


#[allow(dead_code)]
pub async fn redis_delete(
    conn: &mut MultiplexedConnection,
    workspace: &str,
    key: &str,
) -> redis::RedisResult<bool> {

    let deleted: i32 = redis::cmd("HDEL")
        .arg(workspace)
        .arg(key)
        .query_async(conn)
        .await?;

    Ok(deleted > 0)
}



/// redis_connect()
pub async fn redis_connect() -> anyhow::Result<MultiplexedConnection> {
    let default_port = match CONFIG.redis_mode {
        RedisMode::Sentinel => 6379,
        RedisMode::Direct => 6380,
    };

    let urls = CONFIG
        .redis_urls
        .iter()
        .map(|url| {
            redis::ConnectionAddr::Tcp(
                url.host().unwrap().to_string(),
                url.port().unwrap_or(default_port),
            )
        })
        .collect::<Vec<_>>();

    let conn = if CONFIG.redis_mode == RedisMode::Sentinel {
        use redis::sentinel::{SentinelClientBuilder, SentinelServerType};

        let mut sentinel = SentinelClientBuilder::new(
            urls,
            CONFIG.redis_service.to_owned(),
            SentinelServerType::Master,
        )
        .unwrap()
        .set_client_to_redis_protocol(ProtocolVersion::RESP3)
        .set_client_to_redis_db(0)
        .set_client_to_redis_password(CONFIG.redis_password.clone())
        .set_client_to_sentinel_password(CONFIG.redis_password.clone())
        .build()?;

        sentinel.get_async_connection().await?
    } else {
        let single = urls
            .first()
            .ok_or_else(|| anyhow::anyhow!("No redis URL provided"))?;

        let redis_connection_info = RedisConnectionInfo {
            db: 0,
            username: None,
            password: Some(CONFIG.redis_password.clone()),
            protocol: ProtocolVersion::RESP3,
        };

        let connection_info = ConnectionInfo {
            addr: single.clone(),
            redis: redis_connection_info,
        };

        let client = Client::open(connection_info)?;
        client.get_multiplexed_async_connection().await?
    };

    Ok(conn)
}
